namespace DynaDocs.Commands;

using System.CommandLine;
using System.Text;
using DynaDocs.Models;
using DynaDocs.Services;
using DynaDocs.Utils;

public static class FixCommand
{
    private const string AutoGenComment = "<!-- Auto-generated by 'dydo fix'. Do not edit - changes will be overwritten. -->";

    public static Command Create()
    {
        var pathArgument = new Argument<string?>("path")
        {
            DefaultValueFactory = _ => null,
            Description = "Path to docs folder or file to fix"
        };

        var command = new Command("fix", "Auto-fix documentation issues where possible");
        command.Arguments.Add(pathArgument);

        command.SetAction(parseResult =>
        {
            var path = parseResult.GetValue(pathArgument);
            return Execute(path);
        });

        return command;
    }

    private static int Execute(string? path)
    {
        try
        {
            var basePath = ResolvePath(path);
            if (basePath == null)
            {
                ConsoleOutput.WriteError("Could not find docs folder.");
                return ExitCodes.ToolError;
            }

            Console.WriteLine($"Fixing {basePath}...");
            Console.WriteLine();

            var fixedCount = 0;
            var manualFixNeeded = new List<string>();

            var parser = new MarkdownParser();
            var scanner = new DocScanner(parser);
            var docs = scanner.ScanDirectory(basePath);

            // Fix naming issues
            Console.WriteLine("FIXED:");
            foreach (var doc in docs.ToList())
            {
                // Skip excluded paths (same as check command)
                if (IsExcludedPath(doc.RelativePath))
                    continue;

                if (!PathUtils.IsKebabCase(doc.FileName))
                {
                    var newName = PathUtils.ToKebabCase(Path.GetFileNameWithoutExtension(doc.FileName)) + ".md";
                    var newPath = Path.Combine(Path.GetDirectoryName(doc.FilePath)!, newName);

                    File.Move(doc.FilePath, newPath);
                    ConsoleOutput.WriteSuccess($"  ✓ Renamed {doc.FileName} -> {newName}");
                    fixedCount++;
                }
            }

            // Re-scan after renames
            docs = scanner.ScanDirectory(basePath);

            // Fix wikilinks
            var linkResolver = new LinkResolver();
            var linksConverted = 0;

            foreach (var doc in docs)
            {
                var wikilinks = doc.Links.Where(l => l.Type == LinkType.Wikilink).ToList();
                if (wikilinks.Count == 0) continue;

                var content = doc.Content;

                foreach (var link in wikilinks)
                {
                    var resolvedPath = linkResolver.FindFileByName(link.Target + ".md", docs);
                    if (resolvedPath != null)
                    {
                        var relativePath = PathUtils.GetRelativePath(doc.RelativePath, resolvedPath);
                        var newLink = $"[{link.DisplayText}]({relativePath})";
                        content = content.Replace(link.RawText, newLink);
                        linksConverted++;
                    }
                    else
                    {
                        manualFixNeeded.Add($"{doc.RelativePath} - Ambiguous wikilink: {link.RawText}");
                    }
                }

                if (content != doc.Content)
                {
                    File.WriteAllText(doc.FilePath, content);
                }
            }

            if (linksConverted > 0)
            {
                ConsoleOutput.WriteSuccess($"  ✓ Converted {linksConverted} wikilinks to relative paths");
                fixedCount += linksConverted;
            }

            // Regenerate all hub files (process deepest folders first so child hubs exist when processing parents)
            var folders = scanner.GetAllFolders(basePath)
                .OrderByDescending(f => f.Count(c => c == Path.DirectorySeparatorChar || c == '/'))
                .ToList();

            // Track generated hubs so parent folders can find them
            var generatedHubs = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            foreach (var folder in folders)
            {
                var relativeFolderPath = PathUtils.NormalizePath(Path.GetRelativePath(basePath, folder));

                if (relativeFolderPath == ".") continue;

                // Skip excluded folders (same as check command)
                if (IsExcludedFolder(relativeFolderPath))
                    continue;

                // Get docs in this folder (same level only)
                var docsInFolder = docs.Where(d =>
                {
                    var docDir = Path.GetDirectoryName(d.RelativePath) ?? "";
                    docDir = PathUtils.NormalizePath(docDir);
                    return docDir.Equals(relativeFolderPath, StringComparison.OrdinalIgnoreCase);
                }).ToList();

                // Check for existing hub
                var existingHub = docsInFolder.FirstOrDefault(d => d.FileName == "_index.md");

                // Get content docs and subfolder hubs
                var contentDocs = docsInFolder.Where(d => !d.IsHubFile && !d.IsIndexFile).ToList();
                var subfolderHubs = GetSubfolderHubs(folder, docs, basePath, generatedHubs);

                // Skip if no docs, no subfolders, AND no existing hub to regenerate
                if (contentDocs.Count == 0 && !subfolderHubs.Any() && existingHub == null) continue;

                // Generate the full hub content
                var hubPath = Path.Combine(folder, "_index.md");
                var newContent = GenerateFullHub(relativeFolderPath, docsInFolder, subfolderHubs, docs);

                // Track this hub for parent folder detection
                generatedHubs[relativeFolderPath] = newContent;

                // Write if new or changed
                if (existingHub == null || existingHub.Content != newContent)
                {
                    File.WriteAllText(hubPath, newContent);
                    var linkCount = contentDocs.Count;
                    var subfolderCount = subfolderHubs.Count();
                    var action = existingHub == null ? "Created" : "Updated";
                    ConsoleOutput.WriteSuccess($"  ✓ {action} {relativeFolderPath}/_index.md ({linkCount} docs, {subfolderCount} subfolders)");
                    fixedCount++;
                }
            }

            // Create missing meta files for direct children of main folders
            // Only create for folders that have other docs (not empty folders)
            var mainFolders = new[] { "guides", "project", "reference", "understand" };
            foreach (var folder in folders)
            {
                var relativeFolderPath = PathUtils.NormalizePath(Path.GetRelativePath(basePath, folder));
                var parts = relativeFolderPath.Split('/', StringSplitOptions.RemoveEmptyEntries);

                // Only direct children of main folders
                if (parts.Length != 2 || !mainFolders.Contains(parts[0], StringComparer.OrdinalIgnoreCase))
                    continue;

                // Skip hidden folders
                var folderName = parts[1];
                if (folderName.StartsWith("."))
                    continue;

                var metaFileName = $"_{folderName}.md";
                var metaFilePath = Path.Combine(folder, metaFileName);

                // Skip if folder has no docs (besides the meta file itself)
                var docsInFolder = docs.Where(d =>
                {
                    var docDir = Path.GetDirectoryName(d.RelativePath) ?? "";
                    docDir = PathUtils.NormalizePath(docDir);
                    return docDir.Equals(relativeFolderPath, StringComparison.OrdinalIgnoreCase) &&
                           d.FileName != metaFileName;
                }).ToList();

                if (docsInFolder.Count == 0)
                    continue;

                if (!File.Exists(metaFilePath))
                {
                    var content = GenerateMetaFileScaffold(parts[0], folderName);
                    File.WriteAllText(metaFilePath, content);
                    ConsoleOutput.WriteSuccess($"  ✓ Created {relativeFolderPath}/{metaFileName}");
                    fixedCount++;
                }
            }

            // Report manual fixes needed
            docs = scanner.ScanDirectory(basePath);
            foreach (var doc in docs)
            {
                // Skip excluded paths (same as check command)
                if (IsExcludedPath(doc.RelativePath))
                    continue;

                if (!doc.HasFrontmatter)
                    manualFixNeeded.Add($"{doc.RelativePath} - Add frontmatter");
                else if (string.IsNullOrEmpty(doc.SummaryParagraph))
                    manualFixNeeded.Add($"{doc.RelativePath} - Add summary paragraph");
            }

            Console.WriteLine();
            Console.WriteLine($"Fixed {fixedCount} issues automatically.");

            if (manualFixNeeded.Count > 0)
            {
                Console.WriteLine();
                ConsoleOutput.WriteWarning("NEEDS MANUAL FIX:");
                foreach (var item in manualFixNeeded.Distinct())
                {
                    Console.WriteLine($"  ✗ {item}");
                }
                Console.WriteLine();
                Console.WriteLine($"{manualFixNeeded.Distinct().Count()} issues require manual attention.");
            }

            return ExitCodes.Success;
        }
        catch (Exception ex)
        {
            ConsoleOutput.WriteError($"Error: {ex.Message}");
            return ExitCodes.ToolError;
        }
    }

    private static string? ResolvePath(string? path)
    {
        if (!string.IsNullOrEmpty(path))
        {
            if (File.Exists(path) || Directory.Exists(path))
                return Path.GetFullPath(path);
            return null;
        }
        return PathUtils.FindDocsFolder(Environment.CurrentDirectory);
    }

    /// <summary>
    /// Generates a complete hub file with auto-generated comment, frontmatter, contents, and subfolders.
    /// </summary>
    private static string GenerateFullHub(
        string relativeFolderPath,
        IEnumerable<DocFile> docsInFolder,
        IEnumerable<DocFile> subfolderHubs,
        List<DocFile> allDocs)
    {
        var folderName = Path.GetFileName(relativeFolderPath);
        var title = ToTitleCase(folderName);
        var area = GetAreaForFolder(relativeFolderPath);

        var sb = new StringBuilder();
        sb.AppendLine("---");
        sb.AppendLine($"area: {area}");
        sb.AppendLine("type: hub");
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine(AutoGenComment);
        sb.AppendLine();
        sb.AppendLine($"# {title}");
        sb.AppendLine();
        sb.AppendLine("## Contents");
        sb.AppendLine();
        sb.AppendLine(GenerateDocumentLinks(docsInFolder));

        var subfolders = subfolderHubs.ToList();
        if (subfolders.Count > 0)
        {
            sb.AppendLine();
            sb.AppendLine("## Subfolders");
            sb.AppendLine();
            sb.AppendLine(GenerateSubfolderLinks(subfolders, relativeFolderPath, allDocs));
        }

        return sb.ToString().TrimEnd() + "\n";
    }

    /// <summary>
    /// Finds _index.md files in immediate child directories.
    /// Checks both existing docs and newly generated hubs.
    /// </summary>
    private static IEnumerable<DocFile> GetSubfolderHubs(
        string folder,
        List<DocFile> allDocs,
        string basePath,
        Dictionary<string, string> generatedHubs)
    {
        var relativeFolderPath = PathUtils.NormalizePath(Path.GetRelativePath(basePath, folder));

        // First, get existing hubs from allDocs
        var existingHubs = allDocs.Where(d =>
        {
            if (d.FileName != "_index.md") return false;

            var docDir = Path.GetDirectoryName(d.RelativePath) ?? "";
            docDir = PathUtils.NormalizePath(docDir);

            // Check if it's an immediate child (parent is our folder)
            var parentDir = Path.GetDirectoryName(docDir) ?? "";
            parentDir = PathUtils.NormalizePath(parentDir);

            return parentDir.Equals(relativeFolderPath, StringComparison.OrdinalIgnoreCase);
        }).ToList();

        // Also check generatedHubs for newly created hubs
        var generatedSubfolderPaths = generatedHubs.Keys
            .Where(path =>
            {
                var parentDir = Path.GetDirectoryName(path) ?? "";
                parentDir = PathUtils.NormalizePath(parentDir);
                return parentDir.Equals(relativeFolderPath, StringComparison.OrdinalIgnoreCase);
            })
            .ToList();

        // Create placeholder DocFile objects for generated hubs not in allDocs
        foreach (var subfolderPath in generatedSubfolderPaths)
        {
            if (!existingHubs.Any(h =>
                PathUtils.NormalizePath(Path.GetDirectoryName(h.RelativePath) ?? "")
                    .Equals(subfolderPath, StringComparison.OrdinalIgnoreCase)))
            {
                // Create a minimal DocFile for the generated hub
                existingHubs.Add(new DocFile
                {
                    RelativePath = subfolderPath + "/_index.md",
                    FileName = "_index.md",
                    Content = generatedHubs[subfolderPath],
                    FilePath = Path.Combine(basePath, subfolderPath, "_index.md")
                });
            }
        }

        return existingHubs;
    }

    /// <summary>
    /// Generates markdown links for subfolder hub files.
    /// Uses meta file summary if available, otherwise falls back to hub summary.
    /// </summary>
    private static string GenerateSubfolderLinks(IEnumerable<DocFile> subfolderHubs, string parentFolderPath, List<DocFile> allDocs)
    {
        var hubs = subfolderHubs
            .OrderBy(d => d.RelativePath, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (hubs.Count == 0)
            return "*No subfolders.*";

        var sb = new StringBuilder();
        foreach (var hub in hubs)
        {
            var hubDir = Path.GetDirectoryName(hub.RelativePath) ?? "";
            var folderName = Path.GetFileName(hubDir);
            var displayText = ToTitleCase(folderName);
            var relativePath = "./" + folderName + "/_index.md";

            // Try to find meta file for description
            var metaFileName = $"_{folderName}.md";
            var metaFile = allDocs.FirstOrDefault(d =>
                d.FileName == metaFileName &&
                PathUtils.NormalizePath(Path.GetDirectoryName(d.RelativePath) ?? "")
                    .Equals(PathUtils.NormalizePath(hubDir), StringComparison.OrdinalIgnoreCase));

            var description = metaFile != null
                ? GetFirstSentence(metaFile.SummaryParagraph)
                : GetFirstSentence(hub.SummaryParagraph);

            if (!string.IsNullOrEmpty(description))
                sb.AppendLine($"- [{displayText}]({relativePath}) - {description}");
            else
                sb.AppendLine($"- [{displayText}]({relativePath})");
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Gets the area for a folder path (uses top-level folder name).
    /// </summary>
    private static string GetAreaForFolder(string relativeFolderPath)
    {
        var normalized = PathUtils.NormalizePath(relativeFolderPath);
        var topLevel = normalized.Split('/')[0];
        return topLevel.ToLowerInvariant();
    }

    /// <summary>
    /// Converts kebab-case folder name to Title Case.
    /// </summary>
    private static string ToTitleCase(string folderName)
    {
        if (string.IsNullOrEmpty(folderName))
            return folderName;

        return System.Globalization.CultureInfo.CurrentCulture
            .TextInfo.ToTitleCase(folderName.Replace("-", " "));
    }

    /// <summary>
    /// Generates markdown link entries for documents in a folder.
    /// </summary>
    private static string GenerateDocumentLinks(IEnumerable<DocFile> docsInFolder)
    {
        var contentDocs = docsInFolder
            .Where(d => !d.IsHubFile && !d.IsIndexFile)
            .OrderBy(d => d.Title ?? d.FileName, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (contentDocs.Count == 0)
            return "*No documents in this folder yet.*";

        var sb = new StringBuilder();
        foreach (var doc in contentDocs)
        {
            var displayText = GetDisplayText(doc);
            var description = GetFirstSentence(doc.SummaryParagraph);

            if (!string.IsNullOrEmpty(description))
                sb.AppendLine($"- [{displayText}](./{doc.FileName}) - {description}");
            else
                sb.AppendLine($"- [{displayText}](./{doc.FileName})");
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Generates a scaffold meta file for a folder.
    /// </summary>
    private static string GenerateMetaFileScaffold(string area, string folderName)
    {
        var title = ToTitleCase(folderName);
        return $"""
            ---
            area: {area}
            type: folder-meta
            ---

            # {title}

            TODO: Describe the purpose of this folder.
            """;
    }

    private static string GetDisplayText(DocFile doc)
    {
        if (!string.IsNullOrEmpty(doc.Title))
            return doc.Title;

        // Convert "user-auth.md" -> "User Auth"
        var name = Path.GetFileNameWithoutExtension(doc.FileName);
        return System.Globalization.CultureInfo.CurrentCulture
            .TextInfo.ToTitleCase(name.Replace("-", " "));
    }

    private static string GetFirstSentence(string? paragraph)
    {
        if (string.IsNullOrEmpty(paragraph))
            return string.Empty;

        var endMarkers = new[] { ". ", "! ", "? ", ".\n", "!\n", "?\n" };
        var firstEnd = paragraph.Length;

        foreach (var marker in endMarkers)
        {
            var idx = paragraph.IndexOf(marker, StringComparison.Ordinal);
            if (idx >= 0 && idx < firstEnd)
                firstEnd = idx;
        }

        var sentence = firstEnd < paragraph.Length
            ? paragraph[..(firstEnd + 1)].Trim()
            : paragraph.Trim();

        // Truncate if too long
        return sentence.Length > 100 ? sentence[..97] + "..." : sentence;
    }

    /// <summary>
    /// Check if a file path should be excluded from fix operations.
    /// Matches the exclusions used in check rules.
    /// </summary>
    private static bool IsExcludedPath(string relativePath)
    {
        var normalized = PathUtils.NormalizePath(relativePath);

        // Skip template files
        if (normalized.StartsWith("_system/templates/", StringComparison.OrdinalIgnoreCase))
            return true;

        // Skip agent workspace files
        if (normalized.StartsWith("agents/", StringComparison.OrdinalIgnoreCase))
            return true;

        return false;
    }

    /// <summary>
    /// Check if a folder should be excluded from hub file creation.
    /// Matches the exclusions used in HubFilesRule.
    /// </summary>
    private static bool IsExcludedFolder(string relativeFolderPath)
    {
        // Skip system folders
        if (relativeFolderPath.StartsWith("_system", StringComparison.OrdinalIgnoreCase))
            return true;

        // Skip agent workspace folders
        if (relativeFolderPath.StartsWith("agents", StringComparison.OrdinalIgnoreCase))
            return true;

        // Skip assets folder
        if (relativeFolderPath.StartsWith("_assets", StringComparison.OrdinalIgnoreCase))
            return true;

        return false;
    }
}
