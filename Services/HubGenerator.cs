namespace DynaDocs.Services;

using System.Text;
using DynaDocs.Models;
using DynaDocs.Utils;

/// <summary>
/// Generates hub (_index.md) files for documentation folders.
/// Shared between FixCommand and FolderScaffolder for consistent output.
/// </summary>
public static class HubGenerator
{
    private const string AutoGenComment = "<!-- Auto-generated by 'dydo fix'. Do not edit - changes will be overwritten. -->";

    /// <summary>
    /// Generates a complete hub file with auto-generated comment, frontmatter, contents, and subfolders.
    /// </summary>
    public static string GenerateHub(
        string relativeFolderPath,
        IEnumerable<DocFile> docsInFolder,
        IEnumerable<DocFile> subfolderHubs,
        List<DocFile> allDocs)
    {
        var folderName = Path.GetFileName(relativeFolderPath);
        var title = ToTitleCase(folderName);
        var area = GetAreaForFolder(relativeFolderPath);

        var sb = new StringBuilder();
        sb.AppendLine("---");
        sb.AppendLine($"area: {area}");
        sb.AppendLine("type: hub");
        sb.AppendLine("---");
        sb.AppendLine();
        sb.AppendLine(AutoGenComment);
        sb.AppendLine();
        sb.AppendLine($"# {title}");
        sb.AppendLine();
        sb.AppendLine("## Contents");
        sb.AppendLine();
        sb.AppendLine(GenerateDocumentLinks(docsInFolder));

        var subfolders = subfolderHubs.ToList();
        if (subfolders.Count > 0)
        {
            sb.AppendLine();
            sb.AppendLine("## Subfolders");
            sb.AppendLine();
            sb.AppendLine(GenerateSubfolderLinks(subfolders, relativeFolderPath, allDocs));
        }

        return sb.ToString().TrimEnd() + "\n";
    }

    /// <summary>
    /// Generates all hub files for a documentation folder structure.
    /// Returns a dictionary of relative paths to hub content.
    /// </summary>
    public static Dictionary<string, string> GenerateAllHubs(string basePath, List<DocFile> allDocs)
    {
        var generatedHubs = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        var mainFolders = new[] { "guides", "project", "reference", "understand" };

        // Collect all folders that need hubs (folders with docs AND their parent folders)
        var foldersToProcess = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var doc in allDocs.Where(d => !IsExcludedPath(d.RelativePath)))
        {
            var folder = PathUtils.NormalizePath(Path.GetDirectoryName(doc.RelativePath) ?? "");
            if (string.IsNullOrEmpty(folder)) continue;

            // Only process folders under main doc folders
            if (!mainFolders.Any(mf => folder.StartsWith(mf + "/", StringComparison.OrdinalIgnoreCase)
                                    || folder.Equals(mf, StringComparison.OrdinalIgnoreCase)))
                continue;

            // Add this folder and all parent folders up to the main folder
            var current = folder;
            while (!string.IsNullOrEmpty(current))
            {
                foldersToProcess.Add(current);
                var parent = PathUtils.NormalizePath(Path.GetDirectoryName(current) ?? "");
                if (string.IsNullOrEmpty(parent) || !mainFolders.Any(mf =>
                    parent.StartsWith(mf + "/", StringComparison.OrdinalIgnoreCase) ||
                    parent.Equals(mf, StringComparison.OrdinalIgnoreCase)))
                    break;
                current = parent;
            }
        }

        // Process folders depth-first (subfolders before parents)
        var sortedFolders = foldersToProcess
            .OrderByDescending(f => f.Count(c => c == '/'))
            .ToList();

        foreach (var folder in sortedFolders)
        {
            var hubPath = PathUtils.NormalizePath(Path.Combine(folder, "_index.md"));

            // Get docs in this folder (excluding _index.md and meta files)
            var docsInFolder = allDocs.Where(d =>
            {
                var docFolder = PathUtils.NormalizePath(Path.GetDirectoryName(d.RelativePath) ?? "");
                return docFolder.Equals(folder, StringComparison.OrdinalIgnoreCase)
                    && d.FileName != "_index.md"
                    && !d.FileName.StartsWith("_");
            });

            // Get subfolder hubs
            var subfolderHubs = GetSubfolderHubs(folder, allDocs, generatedHubs);

            var content = GenerateHub(folder, docsInFolder, subfolderHubs, allDocs);
            generatedHubs[hubPath] = content;
        }

        return generatedHubs;
    }

    private static IEnumerable<DocFile> GetSubfolderHubs(
        string folder,
        List<DocFile> allDocs,
        Dictionary<string, string> generatedHubs)
    {
        var normalizedFolder = PathUtils.NormalizePath(folder);

        // Get existing hubs from allDocs
        var existingHubs = allDocs.Where(d =>
        {
            if (d.FileName != "_index.md") return false;

            var docDir = Path.GetDirectoryName(d.RelativePath) ?? "";
            docDir = PathUtils.NormalizePath(docDir);

            var parentDir = Path.GetDirectoryName(docDir) ?? "";
            parentDir = PathUtils.NormalizePath(parentDir);

            return parentDir.Equals(normalizedFolder, StringComparison.OrdinalIgnoreCase);
        }).ToList();

        // Also include generated hubs
        foreach (var hubPath in generatedHubs.Keys)
        {
            var hubDir = Path.GetDirectoryName(hubPath) ?? "";
            hubDir = PathUtils.NormalizePath(hubDir);

            var parentDir = Path.GetDirectoryName(hubDir) ?? "";
            parentDir = PathUtils.NormalizePath(parentDir);

            if (parentDir.Equals(normalizedFolder, StringComparison.OrdinalIgnoreCase))
            {
                if (!existingHubs.Any(h => PathUtils.NormalizePath(h.RelativePath).Equals(hubPath, StringComparison.OrdinalIgnoreCase)))
                {
                    existingHubs.Add(new DocFile
                    {
                        RelativePath = hubPath,
                        FileName = "_index.md",
                        FilePath = hubPath,
                        Content = ""
                    });
                }
            }
        }

        return existingHubs;
    }

    private static string GenerateDocumentLinks(IEnumerable<DocFile> docs)
    {
        var sb = new StringBuilder();
        var docList = docs.OrderBy(d => d.FileName).ToList();

        if (docList.Count == 0)
        {
            sb.AppendLine("*No documents in this folder yet.*");
        }
        else
        {
            foreach (var doc in docList)
            {
                var title = doc.Title ?? KebabToTitleCase(Path.GetFileNameWithoutExtension(doc.FileName));
                var summary = doc.SummaryParagraph;
                var link = $"[{title}](./{doc.FileName})";

                if (!string.IsNullOrEmpty(summary))
                {
                    // Truncate summary to first sentence
                    var firstSentence = GetFirstSentence(summary);
                    sb.AppendLine($"- {link} - {firstSentence}");
                }
                else
                {
                    sb.AppendLine($"- {link}");
                }
            }
        }

        return sb.ToString().TrimEnd();
    }

    private static string GenerateSubfolderLinks(
        IEnumerable<DocFile> subfolderHubs,
        string parentFolder,
        List<DocFile> allDocs)
    {
        var sb = new StringBuilder();

        foreach (var hub in subfolderHubs.OrderBy(h => h.RelativePath))
        {
            var hubDir = Path.GetDirectoryName(hub.RelativePath) ?? "";
            var folderName = Path.GetFileName(hubDir);
            var title = ToTitleCase(folderName);

            // Try to get summary from meta file
            var metaFileName = $"_{folderName}.md";
            var metaFile = allDocs.FirstOrDefault(d =>
                PathUtils.NormalizePath(Path.GetDirectoryName(d.RelativePath) ?? "")
                    .Equals(PathUtils.NormalizePath(hubDir), StringComparison.OrdinalIgnoreCase)
                && d.FileName.Equals(metaFileName, StringComparison.OrdinalIgnoreCase));

            var relativePath = $"./{folderName}/_index.md";
            var link = $"[{title}]({relativePath})";

            if (metaFile?.SummaryParagraph != null)
            {
                var firstSentence = GetFirstSentence(metaFile.SummaryParagraph);
                sb.AppendLine($"- {link} - {firstSentence}");
            }
            else
            {
                sb.AppendLine($"- {link}");
            }
        }

        return sb.ToString().TrimEnd();
    }

    private static string GetFirstSentence(string text)
    {
        var endIndex = text.IndexOfAny(['.', '!', '?']);
        if (endIndex > 0 && endIndex < 150)
        {
            return text[..(endIndex + 1)];
        }
        return text.Length > 150 ? text[..147] + "..." : text;
    }

    private static string ToTitleCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToUpper(name[0]) + name[1..];
    }

    /// <summary>
    /// Converts kebab-case to Title Case (e.g., "user-authentication" -> "User Authentication").
    /// </summary>
    private static string KebabToTitleCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return System.Globalization.CultureInfo.CurrentCulture.TextInfo
            .ToTitleCase(name.Replace("-", " "));
    }

    private static string GetAreaForFolder(string relativeFolderPath)
    {
        var normalized = PathUtils.NormalizePath(relativeFolderPath);
        var firstPart = normalized.Split('/')[0];

        return firstPart switch
        {
            "understand" => "understand",
            "guides" => "guides",
            "reference" => "reference",
            "project" => "project",
            _ => "general"
        };
    }

    private static bool IsExcludedPath(string relativePath)
    {
        var normalized = PathUtils.NormalizePath(relativePath);

        // Exclude paths starting with _system, agents, or hidden folders
        if (normalized.StartsWith("_system/", StringComparison.OrdinalIgnoreCase)) return true;
        if (normalized.StartsWith("agents/", StringComparison.OrdinalIgnoreCase)) return true;
        if (normalized.Contains("/.")) return true;

        return false;
    }
}
